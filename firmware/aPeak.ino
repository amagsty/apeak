
#include <MaxMatrix.h>
#include <PZEM004T.h>

float w_raw;
int w,wl,wr;
int light,mIntensity,mIntensity_pre,counter;

byte bar[9]={B00000000,B00000001,B00000011,B00000111,B00001111,B00011111,B00111111,B01111111,B11111111};
byte NL[176]={
  B11111111,B11111111,B00000011,B00000011,B11111111,B11111111,B00000000,B00000011,  B11111111,B11111111,B11000000,B11000000,B11111111,B11111111,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,B00000000,B00000011,  B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,B00000000,B00000000,
  B11111111,B11111111,B00000011,B00000011,B00000011,B00000011,B00000000,B00000011,  B11000011,B11000011,B11000011,B11000011,B11111111,B11111111,B00000000,B00000000,
  B00000011,B00000011,B00000011,B00000011,B11111111,B11111111,B00000000,B00000011,  B11000011,B11000011,B11000011,B11000011,B11111111,B11111111,B00000000,B00000000,
  B11000000,B11000000,B11000000,B11000000,B11111111,B11111111,B00000000,B00000011,  B11111111,B11111111,B00000000,B00000000,B11111111,B11111111,B00000000,B00000000,
  B00000011,B00000011,B00000011,B00000011,B11111111,B11111111,B00000000,B00000011,  B11111111,B11111111,B11000011,B11000011,B11000011,B11000011,B00000000,B00000000,
  B11111111,B11111111,B00000011,B00000011,B11111111,B11111111,B00000000,B00000011,  B11111111,B11111111,B11000011,B11000011,B11000011,B11000011,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,B00000000,B00000011,  B11000000,B11000000,B11000000,B11000000,B11111111,B11111111,B00000000,B00000000,
  B11111111,B11111111,B00000011,B00000011,B11111111,B11111111,B00000000,B00000011,  B11111111,B11111111,B11000011,B11000011,B11111111,B11111111,B00000000,B00000000,
  B11000000,B11000000,B11000000,B11000000,B11111111,B11111111,B00000000,B00000011,  B11111111,B11111111,B11000000,B11000000,B11111111,B11111111,B00000000,B00000000,
  B11111001,B11111001,B00011001,B00011001,B11111001,B11111001,B00000001,B11111001,  B10011111,B10011111,B10011000,B10011000,B10011111,B10011111,B10000000,B10011111,
  };
byte NR[176]={
  B00000011,B00000000,B11111111,B11111111,B00000011,B00000011,B11111111,B11111111,  B00000000,B00000000,B11111111,B11111111,B11000000,B11000000,B11111111,B11111111,
  B00000011,B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,
  B00000011,B00000000,B11111111,B11111111,B00000011,B00000011,B00000011,B00000011,  B00000000,B00000000,B11000011,B11000011,B11000011,B11000011,B11111111,B11111111,
  B00000011,B00000000,B00000011,B00000011,B00000011,B00000011,B11111111,B11111111,  B00000000,B00000000,B11000011,B11000011,B11000011,B11000011,B11111111,B11111111,
  B00000011,B00000000,B11000000,B11000000,B11000000,B11000000,B11111111,B11111111,  B00000000,B00000000,B11111111,B11111111,B00000000,B00000000,B11111111,B11111111,
  B00000011,B00000000,B00000011,B00000011,B00000011,B00000011,B11111111,B11111111,  B00000000,B00000000,B11111111,B11111111,B11000011,B11000011,B11000011,B11000011,
  B00000011,B00000000,B11111111,B11111111,B00000011,B00000011,B11111111,B11111111,  B00000000,B00000000,B11111111,B11111111,B11000011,B11000011,B11000011,B11000011,
  B00000011,B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,  B00000000,B00000000,B11000000,B11000000,B11000000,B11000000,B11111111,B11111111,
  B00000011,B00000000,B11111111,B11111111,B00000011,B00000011,B11111111,B11111111,  B00000000,B00000000,B11111111,B11111111,B11000011,B11000011,B11111111,B11111111,
  B00000011,B00000000,B11000000,B11000000,B11000000,B11000000,B11111111,B11111111,  B00000000,B00000000,B11111111,B11111111,B11000000,B11000000,B11111111,B11111111,
  B11111001,B00011001,B00011001,B00011001,B00011001,B00000001,B11011001,B11011001,  B10011111,B10000000,B10000000,B10000000,B10000000,B10000000,B10011111,B10011111 // L
  };


// din cs clk
MaxMatrix ml(4, 3, 2, 4); 
MaxMatrix mrb(9, 7,8, 3); 
MaxMatrix mrt(12, 10,11, 3); 

// (RX,TX) connect to TX,RX of PZEM
PZEM004T pzem(13,5);  
IPAddress ip(192,168,1,1);

void setup(){
  delay(500);
  ml.init();
  ml.setIntensity(0);
  mrt.init();
  mrt.setIntensity(0); 
  mrb.init();
  mrb.setIntensity(0);  
    
  pzem.setAddress(ip);  
}

void loop(){

  w_raw = pzem.power(ip);
  if (w_raw < 0.0) w_raw = 0.0;

  w=round(w_raw/100)*100;
  wl=w / 1000;
  wr=(w-wl*1000)/100;

  if (w>=9999){
    printNL(10);
    printNR(10);
  } else {
    printNL(wl);
    printNR(wr);        
  }
  
  mrt.shiftRight(false,false);
  mrb.shiftRight(false,false);

  if (w>4000)  {
    if (w>8000) {
      // overload
      mrb.setColumn(0,B11111111); 
      mrt.setColumn(0,B11111111); 
    } else { 
      mrb.setColumn(0,B11111111); 
      mrt.setColumn(0,bar[map(w,4000,8000,0,8)]);
    }
  } else {    
    mrt.setColumn(0,B00000000); 
    mrb.setColumn(0,bar[map(w,0,4000,0,8)]);
  }

  intensityAdp(); 
  delay(1000);
}

void printNL(int n) {
  for (int i=16; i<32; i++){
    ml.setColumn(i,NL[i+n*16-16]); 
  }
}
void printNR(int n) {
  for (int i=0; i<16; i++){
    ml.setColumn(i,NR[i+n*16]); 
  }
}
void intensityAdp(){ 
  if(counter>10){    
    light=analogRead(A0);
    if (light<=400){
      mIntensity=0;
    } else if (light>=800) {
      mIntensity=8;
    } else {
      mIntensity=map(light,400,800,0,8);      
    }
    if (mIntensity!=mIntensity_pre){
      ml.setIntensity(mIntensity);
      mrt.setIntensity(mIntensity); 
      mrb.setIntensity(mIntensity);    
      mIntensity_pre=mIntensity; 
    }
    counter=0;
  } else {
    counter++;
  }
}



